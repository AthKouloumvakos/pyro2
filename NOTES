-- use NumPy vectorization when possible.

   Here's an example (Laplace's equation):

   http://www.scipy.org/PerformancePython

   u[1:-1, 1:-1] = ((u[0:-2, 1:-1] + u[2:, 1:-1])*dy2 +
                    (u[1:-1,0:-2] + u[1:-1, 2:])*dx2)*dnr_inv
 

   ilo:ihi+1  = [ilo, ihi] in set notation

   u[ilo:ihi+1, jlo:jhi+1] = ((u[ilo-1:ihi, jlo:jhi+1] +
                               u[ilo+1:ihi+2, jlo:jhi+1]) + ...

-- tree:

  tree -I CVS -A -C 


-- output library w/ colors
 
  WARNING()
  ERROR()


-- note for interactive plots, we need to have the matplotlib backend
   set to TkAgg.  In ~/.matplotlib/matplotlibrc, set:

   backend: TkAgg

-- x[(x > 3) & (x < 7)]
   x[numpy.where( (x > 3.0) & (x < 7.0) )]

 b = numpy.argsort(a)
 a[b] is sorted

-- is there a way to define a range like ii = [myg.ilo:myg.ihi+1]
   and then do something like ii+1 to get [myg.ilo+1:myg.ihi+2]?

   

