<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
<HEAD>
  <TITLE>pyro: grids</TITLE> 

  <link rel="stylesheet" type="text/css" href="../hydro.css">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">

</HEAD> 

<body id="grids">

<!-- HEADER .............................................................. -->
<!-- to do highlighting:

http://hicksdesign.co.uk/journal/highlighting-current-page-with-css

http://www.richnetapps.com/automatically_highlight_current_page_in/

-->


<div id="header2">
  <h1>hydro by example</h1><br>
  <h3>A simple python-based tutorial on computational methods for hydrodynamics</h3>
</div>

<div id="subhead">
  <h2><a href="/pyro2/index.html" id="intronav">intro</a></h2> &bull;
  <h2><a href="/pyro2/design" id="designnav">design</a></h2> &bull;
  <h2><a href="/pyro2/grids" id="gridnav">grids</a></h2> &bull;
  <h2><a href="/pyro2/advection" id="advectnav">advection</a></h2> &bull;
  <h2><a href="/pyro2/compressible" id="compnav">compressible</a></h2> &bull;
  <h2><a href="/pyro2/multigrid" id="mgnav">multigrid</a></h2> &bull;
  <h2><a href="/pyro2/diffusion" id="diffnav">diffusion</a></h2> &bull;
  <h2><a href="/pyro2/incompressible" id="incompnav">incompressible</a></h2> &bull;
  <h2><a href="/pyro2/lm_atm" id="lmatmnav">low Mach</a></h2>  &nbsp;|&nbsp;

  <h2><a href="/pyro2/analysis" id="annav">analysis</a></h2> &nbsp;|&nbsp;

  <h2><a href="/pyro2/download" id="dlnav">download</a></h2> 

</div>




<!-- MAIN ................................................................ -->
<div id="main">


<P><h2>&lowast; Finite-volume discretization</h2>

<p>All solvers are based on a finite-volume/cell-centered
discretization.  The basic theory of
such methods is discussed in Chapter 2 of the notes:

<div class="pdf"><a href="http://bender.astro.sunysb.edu/hydro_by_example/CompHydroTutorial.pdf">notes on computational hydro</a></div>

<p><h2>&lowast; <tt>mesh.patch</tt> implementation and use</h2>

<p>The <tt>mesh.patch</tt> module provides all of the functionality
we need to describe 2-d data on a cell-centered/finite-volume grid.

<p>There are 3 main objects in the patch class that we interact with:
<ul>
<li><tt>Grid2d</tt>: this is the main grid object.  It is basically
  a container that holds the number of zones in each coordinate direction,
  the domain extrema, and the coordinates of the zones themselves (both
  at the edges and center).</li>

<li><tt>CellCenterData2d</tt>: this is the main data object&mdash;it holds cell-centered
  data on a grid.  

  <p>To build a <tt>CellCenterData2d</tt> object you need to pass in
  the <tt>Grid2d</tt> object that defines the mesh.
  The <tt>CellCenterData2d</tt> object then allocates storage for the
  unknowns that live on the grid.  This class also provides methods to
  fill boundary conditions, retrieve the data in different fashions,
  and read and write the object from/to disk.</li>

<li><tt>BCObject</tt>: This is simply a container that holds the
  names of the boundary conditions on each edge of the domain.</li>
</ul>

The procedure for setting up a grid and the data that lives on it is as
follows:

<pre class="code">
import mesh.patch as patch

myg = patch.Grid2d(16,32, xmax=1.0, ymax=2.0)
</pre>
This creates the 2-d grid object <tt>myg</tt> with 16 zones in the 
x-direction and 32 zones in the y-direction.  It also specifies the
physical coordinate of the rightmost edge in x and y.

<pre class="code">
mydata = patch.CellCenterData2d(myg)

bc = patch.BCObject(xlb="periodic", xrb="periodic", ylb="reflect-even", yrb="outflow")

mydata.register_var("a", bc)
mydata.create()
</pre>
This creates the cell-centered data object, <tt>mydata</tt> that lives on
the grid we just built above.  Next we create a boundary condition object,
specifying the type of boundary conditions for each edge of the domain,
and finally use this to register a variable, "<tt>a</tt>" that lives on the 
grid.  Once we call the <tt>create()</tt> method, the storage for the 
variables is allocated and we can no longer add variables to the grid.

<p>Note that each variable needs to specify
a <tt>BCObject</tt>&mdash;this allows us to do different actions for
each variable (for example, some may do even reflection while others
may do odd reflection).

<pre class="code">
print mydata
</pre>
This prints out some basic info about the data stored in
the <tt>mydata</tt> object.  The output is below:
<pre class="output">
cc data: nx = 16, ny = 32, ng = 1
         nvars = 1
         variables: 
                     a: min:    0.0000000000    max:    0.0000000000
                        BCs: -x: periodic     +x: periodic     -y: reflect-even +y: outflow     
</pre>

<h3>Tests</h3>

<p>The actual filling of the boundary conditions is done by
the <tt>fill_BC()</tt> method.  The script <tt>bc_test.py</tt> tests
the various types of boundary conditions by initializing a small grid
with sequential data, filling the BCs, and printing out the results.

<h3>Help</h3>
<p>To see a short description of all the methods and functions provided by 
<tt>patch</tt> just type "<tt>help(patch)</tt>" at the 
python prompt.

</div>  <!-- main -->



<!-- FOOTER .............................................................. -->
<div id="footer">
   <a href="/pyro2/help/">get help</a>&nbsp;|&nbsp;
   <a href="/pyro2/acknowledgments/">acknowledgments</a>&nbsp;|&nbsp;
   <a href="http://www.astro.sunysb.edu/mzingale/">Michael Zingale</a> (Stony Brook) &bull;
</div>



</BODY>
</HTML>



